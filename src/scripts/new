#!/usr/bin/env bash
set -euo pipefail

## Create a new branch initialized to origin/main.
## Options:
##   -b   After creating the branch, set branch.<new>.base to the branch we started from.
##   -h   Show help.

usage() {
    echo "Usage: $(basename "$0") [-b] <branch-name>" >&2
}

SET_BASE=0
while getopts ":bh" opt; do
    case "$opt" in
    b) SET_BASE=1 ;;
    h)
        usage
        exit 0
        ;;
    \?)
        echo "Error: invalid option -$OPTARG" >&2
        usage
        exit 2
        ;;
    esac
done
shift $((OPTIND - 1))

if [[ $# -ne 1 ]]; then
    usage
    exit 2
fi

BRANCH="$1"

# Ensure we're in a git work tree
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "Error: not inside a git repository." >&2
    exit 1
fi

# Abort if there are unstaged changes (working tree differs from index)
if ! git diff --quiet; then
    echo "Error: unstaged changes detected. Please stash or commit them before running 'new'." >&2
    exit 1
fi

# Check if branch already exists locally
if git show-ref --verify --quiet "refs/heads/${BRANCH}"; then
    echo "Branch '${BRANCH}' already exists. Nothing to do."
    exit 0
fi

echo "Fetching from origin..."
git fetch origin

# Ensure origin/main exists
if ! git show-ref --verify --quiet "refs/remotes/origin/main"; then
    echo "Error: 'origin/main' not found after fetch." >&2
    exit 1
fi

# Remember the branch we're currently on (to optionally set as base)
PREV_BRANCH="$(git rev-parse --abbrev-ref HEAD)"

echo "Creating branch '${BRANCH}'..."
git switch -c "${BRANCH}"

echo "Hard resetting '${BRANCH}' to 'origin/main'..."
git reset --hard origin/main

if [[ $SET_BASE -eq 1 ]]; then
    base "$PREV_BRANCH"
    echo "Set branch.${BRANCH}.base=${PREV_BRANCH}"
fi

echo "Branch '${BRANCH}' created and set to 'origin/main'."
